# -*- mode: python; -*-

import re
import sys

Import(
    [
        "env",
        "has_option",
        "get_option",
        "use_libunwind",
        "version_extra",
        "version_parts",
    ]
)

env = env.Clone()

env.InjectMongoIncludePaths()

env.AppendUnique(
    FORCEINCLUDES=[
        "mongo/platform/basic.h",
    ],
)

env.SConscript(
    dirs=[
        "base",
        "bson",
        "client",
        "crypto",
        "db",
        "dbtests",
        "embedded",
        "executor",
        "idl",
        "installer",
        "logv2",
        "platform",
        "resmoke",
        "rpc",
        "s",
        "scripting",
        "shell",
        "stdx",
        "tools",
        "transport",
        "unittest",
        "util",
        "watchdog",
    ],
    exports=[
        "env",
    ],
)

sys.path.append("src/mongo")
from src.mongo.mongo_config_header import get_config_header_substs


def makeConfigHeaderDefine(self, key):
    val = "// #undef {0}".format(key)
    if key in self["CONFIG_HEADER_DEFINES"]:
        val = "#define {0} {1}".format(key, self["CONFIG_HEADER_DEFINES"][key])
    return val


env.AddMethod(makeConfigHeaderDefine)

generateConfigHeaderFile = env.Substfile(
    "config.h.in",
    SUBST_DICT=[(k, env.makeConfigHeaderDefine(v)) for (k, v) in get_config_header_substs()],
)
env.Alias("generated-sources", generateConfigHeaderFile)

# NOTE: The 'base' library does not really belong here. Its presence
# here is temporary. Do not add to this library, do not remove from
# it, and do not declare other libraries in this file.
baseEnv = env.Clone()

if use_libunwind == True:
    baseEnv.InjectThirdParty("unwind")
baseEnv.InjectThirdParty("intel_decimal128")

# Stage the top-level mongodb banners

distsrc = env.Dir("#distsrc")
env.AutoInstall(
    target="$PREFIX",
    source=[
        distsrc.File("README"),
        # TODO: we need figure out what to do when we use a different
        # THIRD-PARTY-NOTICES for example, with Embedded
        distsrc.File("THIRD-PARTY-NOTICES"),
        distsrc.File("MPL-2"),
    ],
    AIB_COMPONENT="common",
    AIB_COMPONENTS_EXTRA=["dist", "dist-test"],
    AIB_ROLE="base",
)

# If no module has introduced a file named LICENSE-Enterprise.txt then this
# is a Community build, so inject the AGPL and the Community license
enterprise_license = [
    banner for banner in env["MODULE_BANNERS"] if banner.name == "LICENSE-Enterprise.txt"
]
if not enterprise_license:
    env.Append(MODULE_BANNERS=[distsrc.File("LICENSE-Community.txt")])

# All module banners get staged to the top level of the tarfile, so we
# need to fail if we are going to have a name collision.
module_banner_filenames = set([f.name for f in env["MODULE_BANNERS"]])
if not len(module_banner_filenames) == len(env["MODULE_BANNERS"]):
    # TODO: Be nice and identify conflicts in error.
    env.FatalError("ERROR: Filename conflicts exist in module banners.")

env.AutoInstall(
    target="$PREFIX",
    source=env.get("MODULE_BANNERS", []),
    AIB_COMPONENT="common",
    AIB_COMPONENTS_EXTRA=["dist", "dist-test"],
    AIB_ROLE="base",
)

if env.TargetOSIs("darwin", "macOS"):
    env.AutoInstall(
        target="$PREFIX",
        source=[
            env.File("#/etc/macos_mongodb.plist"),
        ],
        AIB_COMPONENT="common",
        AIB_COMPONENTS_EXTRA=["dist", "dist-test"],
        AIB_ROLE="base",
    )
