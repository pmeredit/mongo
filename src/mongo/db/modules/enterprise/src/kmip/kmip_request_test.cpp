/**
 *  Copyright (C) 2015 MongoDB Inc.
 */
/**
 *
 * This is a mapping between hexadecimal values and the data they encode within KMIP Requests. The
 * message below is from the 'DiscoverVersions' request (it has a request payload of size zero).
 * KMIP version 1.2
 *
 * IT == ItemType
 *
 * Variable hex values between different requests:
 *      i.      RequestSizeData
 *      ii.     BatchItemSize (minimum 0x18 for an empty response)
 *      iii.    OperationType
 *      iv.     RequestPayloadSize
 *      v.      Payload
 * ----------------START OF REQUEST----------------
 * [    MessageTag   | IT |   RequestSizeData     ]
 *  0x42, 0x00, 0x78, 0x01, 0x00, 0x00, 0x00, {0x60},
 * [  RequestHeader  | IT |  RequestHeaderSize    ]
 *  0x42, 0x00, 0x77, 0x01, 0x00, 0x00, 0x00, 0x38,
 * [ ProtoVersionTag | IT | ProtocolMessageSize   ]
 *  0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20,
 * [  ProtoMajorTag  | IT |   IntegerByteLength   ]
 *  0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04,
 * [      MajorVersion     |       Padding        ]
 *  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
 * [  ProtoMinorTag  | IT |   IntegerByteLength   ]
 *  0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04,
 * [     MinorVersion     |       Padding        ]
 *  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
 * [  BatchCountTag  | IT |     IntByteLength     ]
 *  0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04,
 * [       BatchCount      |       Padding        ]
 *  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
 * ^-----------END OF REQUEST HEADER --------------
 * ------------START OF REQUEST BODY--------------v
 * [  BatchItemTag   | IT  |      BatchItemSize   ]
 *  0x42, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, {0x18},
 * [   OperationTag  | IT  |    EnumByteLength    ]
 *  0x42, 0x00, 0x5C, 0x05, 0x00, 0x00, 0x00, 0x04,
 * [      OperationType     |       Padding       ]
 *  {0x00, 0x00, 0x00, 0x1E}, 0x00, 0x00, 0x00, 0x00,
 * [RequestPayloadTag| IT |   RequestPayloadSize  ]
 *  0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, {0x00}
 * ----------START OF REQUEST PAYLOAD---------------
 */

#include "kmip_request.h"
#include "mongo/unittest/unittest.h"
#include "mongo/util/hex.h"

namespace mongo {
namespace {

const size_t kMinExpectedOutputSize = 104U;
const size_t kOperationTypeIndex = 91U;
const size_t kRequestSizeDataIndex = 7U;
const size_t kBatchItemSizeIndex = 79U;
const size_t kRequestPayloadSizeIndex = 103U;
const size_t kVersionMajorIndex = 35U;
const size_t kVersionMinorIndex = 51U;

void printExpectedOutput(std::vector<uint8_t> const& output) {
    int count = 0;
    for (auto val : output) {
        count++;
        std::cout << unsignedHex(+val) << " ";
        if (count % 8 == 0) {
            std::cout << '\n';
        }
    }
    std::cout << '\n' << std::endl;
}

// clang-format off
std::vector<uint8_t> expectedOutput = {
    0x42, 0x00, 0x78, 0x01, 0x00, 0x00, 0x00, 0xFF,
    0x42, 0x00, 0x77, 0x01, 0x00, 0x00, 0x00, 0x38,
    0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20,
    0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04,
    0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04,
    0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
    0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x42, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0xFF,
    0x42, 0x00, 0x5C, 0x05, 0x00, 0x00, 0x00, 0x04,
    0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
    0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0xFF};
// clang-format on

std::vector<uint8_t>& buildExpectedOutput(uint8_t operationType,
                                          std::vector<uint8_t> const& requestSizes,
                                          std::vector<uint8_t> const& payload,
                                          uint8_t* version) {
    // The requestSizes vector describes the total request size, batch item size and request payload
    // size.
    ASSERT(requestSizes.size() == 3);

    // Reset the expectedOutput vector by removing the request payload.
    if (expectedOutput.size() > kMinExpectedOutputSize) {
        expectedOutput.erase(expectedOutput.begin() + kMinExpectedOutputSize, expectedOutput.end());
    }

    expectedOutput[kOperationTypeIndex] = operationType;
    expectedOutput[kRequestSizeDataIndex] = requestSizes[0];
    expectedOutput[kBatchItemSizeIndex] = requestSizes[1];
    expectedOutput[kRequestPayloadSizeIndex] = requestSizes[2];
    expectedOutput[kVersionMajorIndex] = version[0];
    expectedOutput[kVersionMinorIndex] = version[1];

    expectedOutput.insert(expectedOutput.end(), payload.begin(), payload.end());

    return expectedOutput;
}

void testOnEachVersion(std::function<void(uint8_t*)> fn) {
    auto* originalVersion = encryptionGlobalParams.kmipParams.version;
    ScopeGuard resetVersion([&] { encryptionGlobalParams.kmipParams.version = originalVersion; });
    for (auto* version :
         {(uint8_t*)mongo::kmip::KMIPVersion10, (uint8_t*)mongo::kmip::KMIPVersion12}) {
        encryptionGlobalParams.kmipParams.version = version;
        fn(version);
    }
}

TEST(KMIPRequestGeneration, CreateSymmetricKey) {
    testOnEachVersion([&](uint8_t* version) {
        std::vector<uint8_t> algorithm(std::begin(mongo::kmip::aesCryptoAlgorithm),
                                       std::end(mongo::kmip::aesCryptoAlgorithm));
        std::vector<uint8_t> length = mongo::kmip::convertIntToBigEndianArray(128);
        std::vector<uint8_t> usageMask;
        usageMask.push_back(0x00);
        usageMask.push_back(0x00);
        usageMask.push_back(0x00);
        usageMask.push_back(0x0C);

        mongo::kmip::CreateKMIPRequestParameters createParams(algorithm, length, usageMask);
        auto createOutputS = *mongo::kmip::encodeKMIPRequest(createParams);
        std::vector<uint8_t> createOutput(createOutputS.begin(), createOutputS.end());

        // clang-format off
        std::vector<uint8_t> expectedOutput = {
            0x42, 0x00, 0x78, 0x01, 0x00, 0x00, 0x01, 0x20,
            0x42, 0x00, 0x77, 0x01, 0x00, 0x00, 0x00, 0x38,
            0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20,
            0x42, 0x00, 0x6a, 0x02, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, version[0], 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x6b, 0x02, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, version[1], 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x0d, 0x02, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x0f, 0x01, 0x00, 0x00, 0x00, 0xd8,
            0x42, 0x00, 0x5c, 0x05, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0xc0,
            0x42, 0x00, 0x57, 0x05, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x91, 0x01, 0x00, 0x00, 0x00, 0xa8,
            0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30,
            0x42, 0x00, 0x0a, 0x07, 0x00, 0x00, 0x00, 0x17,
            0x43, 0x72, 0x79, 0x70, 0x74, 0x6f, 0x67, 0x72,
            0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x41, 0x6c,
            0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x00,
            0x42, 0x00, 0x0b, 0x05, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30,
            0x42, 0x00, 0x0a, 0x07, 0x00, 0x00, 0x00, 0x14,
            0x43, 0x72, 0x79, 0x70, 0x74, 0x6f, 0x67, 0x72,
            0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x4c, 0x65,
            0x6e, 0x67, 0x74, 0x68, 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x0b, 0x02, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30,
            0x42, 0x00, 0x0a, 0x07, 0x00, 0x00, 0x00, 0x18,
            0x43, 0x72, 0x79, 0x70, 0x74, 0x6f, 0x67, 0x72,
            0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x55, 0x73,
            0x61, 0x67, 0x65, 0x20, 0x4d, 0x61, 0x73, 0x6b,
            0x42, 0x00, 0x0b, 0x02, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00};
        // clang-format on 

        ASSERT(createOutput == expectedOutput);
    });
}

TEST(KMIPRequestGeneration, GetSymmetricKey) {
    testOnEachVersion([&](uint8_t* version) {
        const uint8_t uidx[] = {0x34, 0x39, 0x61, 0x31, 0x63, 0x61, 0x38, 0x38, 0x2D, 0x36, 0x62, 0x65,
                                0x61, 0x2D, 0x34, 0x66, 0x62, 0x32, 0x2D, 0x62, 0x34, 0x35, 0x30, 0x2D,
                                0x37, 0x65, 0x35, 0x38, 0x38, 0x30, 0x32, 0x63, 0x33, 0x30, 0x33, 0x38};
        std::vector<uint8_t> uid(std::begin(uidx), std::end(uidx));

        mongo::kmip::GetKMIPRequestParameters getParams(uid);
        auto getOutputS = *mongo::kmip::encodeKMIPRequest(getParams);
        std::vector<uint8_t> getOutput(getOutputS.begin(), getOutputS.end());

        // clang-format off
        std::vector<uint8_t> expectedOutput = {
            0x42, 0x00, 0x78, 0x01, 0x00, 0x00, 0x00, 0x90,
            0x42, 0x00, 0x77, 0x01, 0x00, 0x00, 0x00, 0x38,
            0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20,
            0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, version[0], 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, version[1], 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x48,
            0x42, 0x00, 0x5C, 0x05, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0x30,
            0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24,
            0x34, 0x39, 0x61, 0x31, 0x63, 0x61, 0x38, 0x38,
            0x2D, 0x36, 0x62, 0x65, 0x61, 0x2D, 0x34, 0x66,
            0x62, 0x32, 0x2D, 0x62, 0x34, 0x35, 0x30, 0x2D,
            0x37, 0x65, 0x35, 0x38, 0x38, 0x30, 0x32, 0x63,
            0x33, 0x30, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00};
        // clang-format on

        ASSERT(getOutput == expectedOutput);
    });
}

TEST(KMIPRequestGeneration, Encrypt) {
    // Note that encrypt, decrypt, and discover versions payloads are never actually built with KMIP
    // protocol version 1.0 as they don't exist. However, we still check that they produce the
    // expected payload for 1.0 for sanity.
    testOnEachVersion([&](uint8_t* version) {
        std::vector<uint8_t> uid = {'1', '2', '3'};
        std::vector<uint8_t> _data = {0xA, 0xB, 0xC};
        SecureVector<uint8_t> data(_data.begin(), _data.end());

        mongo::kmip::EncryptKMIPRequestParameters getParams(uid, data);
        auto encOutputS = *mongo::kmip::encodeKMIPRequest(getParams);
        std::vector<uint8_t> encOutput(encOutputS.begin(), encOutputS.end());

        // clang-format off
        std::vector<uint8_t> expectedOutput = {
            0x42, 0x00, 0x78, 0x01, 0x00, 0x00, 0x00, 0x80,
            0x42, 0x00, 0x77, 0x01, 0x00, 0x00, 0x00, 0x38,
            0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20,
            0x42, 0x00, 0x6a, 0x02, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, version[0], 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x6b, 0x02, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, version[1], 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x0d, 0x02, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x0f, 0x01, 0x00, 0x00, 0x00, 0x38,
            0x42, 0x00, 0x5c, 0x05, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0x20,
            0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x03,
            0x31, 0x32, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0xc2, 0x08, 0x00, 0x00, 0x00, 0x03,
            0x0a, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00};
        // clang-format on
        ASSERT(encOutput == expectedOutput);
    });
}

TEST(KMIPRequestGeneration, Decrypt) {
    testOnEachVersion([&](uint8_t* version) {
        std::vector<uint8_t> uid = {'1', '2', '3'};
        std::vector<uint8_t> data = {0xA, 0xB, 0xC};
        std::vector<uint8_t> iv = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};

        mongo::kmip::DecryptKMIPRequestParameters getParams(uid, iv, data);
        auto decOutputS = *mongo::kmip::encodeKMIPRequest(getParams);
        std::vector<uint8_t> decOutput(decOutputS.begin(), decOutputS.end());

        // clang-format off
        std::vector<uint8_t> expectedOutput = { 
            0x42, 0x00, 0x78, 0x01, 0x00, 0x00, 0x00, 0x98,
            0x42, 0x00, 0x77, 0x01, 0x00, 0x00, 0x00, 0x38,
            0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20,
            0x42, 0x00, 0x6a, 0x02, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, version[0], 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x6b, 0x02, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, version[1], 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x0d, 0x02, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x0f, 0x01, 0x00, 0x00, 0x00, 0x50,
            0x42, 0x00, 0x5c, 0x05, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0x38,
            0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x03,
            0x31, 0x32, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0xc2, 0x08, 0x00, 0x00, 0x00, 0x03,
            0x0a, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x42, 0x00, 0x3d, 0x08, 0x00, 0x00, 0x00, 0x0c,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x09, 0x0a, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00};
        // clang-format on
        ASSERT(decOutput == expectedOutput);
    });
}

TEST(KMIPRequestGeneration, DiscoverVersions) {
    testOnEachVersion([&](uint8_t* version) {
        mongo::kmip::DiscoverVersionsKMIPRequestParameters discoverParams;
        auto discoverOutputS = *mongo::kmip::encodeKMIPRequest(discoverParams);
        std::vector<uint8_t> discoverOutput(discoverOutputS.begin(), discoverOutputS.end());

        std::vector<uint8_t> requestSizes = {0x60, 0x18, 0x00};
        std::vector<uint8_t> payload = {};
        std::vector<uint8_t> expectedOutput =
            buildExpectedOutput(0x1E, requestSizes, payload, version);
        ASSERT(discoverOutput == expectedOutput);
    });
}

TEST(KMIPRequestGeneration, Activate) {
    testOnEachVersion([&](uint8_t* version) {
        std::vector<uint8_t> uid = {'1', '2', '3'};

        mongo::kmip::ActivateKMIPRequestParameters activateParams(uid);
        auto activateOutputS = *mongo::kmip::encodeKMIPRequest(activateParams);
        std::vector<uint8_t> activateOutput(activateOutputS.begin(), activateOutputS.end());

        std::vector<uint8_t> requestSizes = {0x70, 0x28, 0x10};
        //  [     UIDTag    |  IT  |       SizeOfUid      ]
        //  [      UID      |      |        Padding       ]
        // clang-format off
        std::vector<uint8_t> payload = {0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x03,
                                        0x31, 0x32, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00};
        // clang-format on
        std::vector<uint8_t> expectedOutput =
            buildExpectedOutput(0x12, requestSizes, payload, version);
        ASSERT(activateOutput == expectedOutput);
    });
}

TEST(KMIPRequestGeneration, GetAttributes) {
    testOnEachVersion([&](uint8_t* version) {
        std::vector<uint8_t> uid = {'1', '2', '3'};
        std::string attribute = "State";
        std::vector<uint8_t> attributeName = {std::begin(attribute), std::end(attribute)};

        mongo::kmip::GetAttributesKMIPRequestParameters getAttributesParams(uid, attributeName);
        auto getAttributesS = *mongo::kmip::encodeKMIPRequest(getAttributesParams);
        std::vector<uint8_t> getAttributesOutput(getAttributesS.begin(), getAttributesS.end());

        std::vector<uint8_t> requestSizes = {0x80, 0x38, 0x20};
        //  [     UIDTag    |  IT  |       SizeOfUid      ]
        //  [      UID       |           Padding          ]
        //  [attributeNameTag| IT |      SizeOfName       ]
        //  [        AttributeName       |    Padding     ]
        // clang-format off
        std::vector<uint8_t> payload = {0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x03,
                                        0x31, 0x32, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
                                        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x05,
                                        0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00};
        // clang-format on
        std::vector<uint8_t> expectedOutput =
            buildExpectedOutput(0x0B, requestSizes, payload, version);
        ASSERT(getAttributesOutput == expectedOutput);
    });
}

}  // namespace
}  // namespace mongo
